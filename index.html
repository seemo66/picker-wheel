<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Picker Wheel </title>
  <style>
/* Picker Wheel Styles */
/*
  Theme customization:
  - Update the variables in :root to change fonts and brand colors.
  - These variables control buttons, inputs, headings, and modal accents.
*/

:root {
  --font-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  --font-heading: BlinkMacSystemFont, -apple-system, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", "Helvetica", "Arial", sans-serif;
  --color-text: #555;
  --color-primary: #3fb8af;           /* Buttons background */
  --color-primary-border: #32938c;    /* Buttons/input border focus */
  --color-accent: #ee7e8d;            /* Delete/edit accent */
  --color-modal-bg: #f8f8f8;          /* Winner row background */
  --color-border: #ddd;               /* Neutral borders */
}

/* Base styles */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
}

.picker-wheel-demo {
  width: 100%;
  min-height: 100vh;
  overflow-x: hidden;
}

/* Scoped box-sizing for picker wheel elements */
.picker-wheel-wrapper,
.picker-wheel-wrapper * {
  box-sizing: border-box;
}

/* Demo Container */
.demo-container {
  max-width: 600px;
  margin: 40px auto;
  padding: 20px;
  font-family: var(--font-base);
}

.demo-container h1 {
  text-align: center;
  font-size: 36px;
  color: var(--color-text);
  margin-bottom: 30px;
  font-family: var(--font-heading);
}

/* Apply heading font stack consistently */
.demo-container h2,
.demo-container h3,
.result-modal-content h2 {
  font-family: var(--font-heading);
}

/* Options Input Section */
.options-input-section {
  display: flex;
  gap: 10px;
  margin-bottom: 0px;
  align-items: flex-start;
  flex-wrap: wrap;
}

/* Wheel Section */
.wheel-section {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-bottom: 30px;
  min-height: 500px;
}

.wheel-canvas {
  width: 100%;
  max-width: 500px;
  aspect-ratio: 1;
  position: relative;
  overflow: hidden; /* Prevent arrow/shadow from causing horizontal overflow */
}

.wheel-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
  transform-origin: center;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(var(--rotation, 360deg));
  }
}

.wheel-svg {
  width: 100%;
  height: 100%;
}

.wheel-arrow {
  position: absolute;
  width: 0;
  height: 0;
  /* Create a triangle pointing left (toward wheel) */
  border-top: 15px solid transparent;
  border-bottom: 15px solid transparent;
  border-right: 30px solid var(--color-accent);
  
  /* Position on the right side of wheel, middle height */
  top: 50%;
  right: 35px;
  transform: translateY(-50%);
  
  z-index: 5;
}

.wheel-arrow-svg {
  position: absolute;
  width: 40px;
  height: 50px;
  top: 50%;
  right: 20px; /* Anchor to the right edge inside canvas */
  transform: translateY(-50%);
  z-index: 5;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.25));
}

.spin-btn {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background-color: #fff;
  border: 3px solid var(--color-text);
  font-weight: bold;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  transition: background-color 0.3s, transform 0.2s;
  z-index: 10;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  line-height: 1.2;
}

.spin-btn:hover:not(:disabled) {
  background-color: var(--color-modal-bg);
  transform: translate(-50%, -50%) scale(1.1);
}

.spin-btn:active:not(:disabled) {
  transform: translate(-50%, -50%) scale(0.95);
}

.spin-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.option-input {
  flex: 1;
  padding: 10px 15px;
  font-size: 16px;
  border: 2px solid var(--color-border);
  border-radius: 4px;
  transition: border-color 0.3s;
  width: 100%;
}

.option-input:focus {
  outline: none;
  border-color: var(--color-primary-border);
}

.option-input:active {
  border-color: var(--color-primary-border);
}

.feedback-message {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 4px;
  order: 3;
  flex-basis: 100%;
  margin: 0;
  min-height: 23px;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.feedback-message.show {
  opacity: 1;
}

.feedback-message.error {
  color: #c33;
}

.feedback-message.success {
  background-color: #efe;
  color: #3a3;
  border: 1px solid #cfc;
}

.add-btn {
  padding: 12px 30px;
  font-size: 16px;
  background-color: var(--color-primary);
  color: white;
  border: 1px solid var(--color-primary-border);
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
  white-space: nowrap;
}

.add-btn:hover {
  background-color: var(--color-primary);
}

.add-btn:active {
  background-color: var(--color-primary);
}

/* Options List */
.options-list {
  margin-top: 10px;
}

.options-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.options-list h3 {
  color: var(--color-text);
  margin-bottom: 0;
  margin-top: 0;
}

.clear-all-btn {
  padding: 8px 16px;
  font-size: 13px;
  background-color: var(--color-primary);
  color: white;
  border: 1px solid var(--color-primary-border);
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
  white-space: nowrap;
}

.clear-all-btn:hover {
  background-color: var(--color-primary);
}

.clear-all-btn:active {
  background-color: var(--color-primary);
}

.options-ol {
  padding-left: 15px;
  margin: 0;
}

.options-ol li {
  padding: 8px 0;
  color: var(--color-text);
  line-height: 1.6;
}

.option-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.option-text {
  flex: 1;
}

.option-buttons {
  display: flex;
  gap: 5px;
}

.edit-btn,
.delete-btn {
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text);
  transition: transform 0.15s ease, color 0.15s ease;
}

.edit-btn:hover {
  transform: scale(1.2);
  color: var(--color-primary);
}

.delete-btn:hover {
  transform: scale(1.2);
  color: var(--color-accent);
}

.option-input-edit {
  flex: 1;
  padding: 8px 12px;
  font-size: 14px;
  border: 2px solid var(--color-accent);
  border-radius: 3px;
  font-family: inherit;
}

.option-input-edit:focus {
  outline: none;
  border-color: var(--color-accent);
  box-shadow: 0 0 0 2px rgba(238, 126, 141, 0.2);
}

.wheel-placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  color: var(--color-text);
  font-size: 18px;
  text-align: center;
  padding: 20px;
}

.edit-actions {
  display: flex;
  gap: 5px;
}

.save-btn,
.cancel-btn {
  padding: 6px 12px;
  font-size: 12px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.save-btn {
  background-color: var(--color-accent);
  color: white;
}

.save-btn:hover {
  background-color: #ee7e8d;
}

.cancel-btn {
  background-color: #999;
  color: white;
}

.cancel-btn:hover {
  background-color: #777;
}

/* Responsive */
@media (max-width: 600px) {
  .demo-container {
    padding: 15px;
    margin: 15px auto;
  }

  .demo-container h1 {
    margin-bottom: 15px;
    font-size: 1.5rem;
  }

  .wheel-section {
    margin-bottom: 15px;
    min-height: auto;
  }

  .options-input-section {
    flex-direction: column;
  }

  .add-btn {
    width: 100%;
  }
}

/* Result Modal */
.result-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.result-modal.show {
  display: flex;
}

.result-modal-content {
  background-color: white;
  padding: 40px 50px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  animation: slideIn 0.3s ease-out;
  width: min(450px, 70vw);
  max-width: 70vw;
}

@keyframes slideIn {
  from {
    transform: translateY(-50px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.result-modal-content h2 {
  margin: 0 0 30px 0;
  color: var(--color-text);
  font-size: 32px;
  text-align: center;
}

.result-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  padding: 20px;
  background-color: var(--color-modal-bg);
  border-radius: 8px;
  margin-bottom: 24px;
}

.result-text {
  font-size: 36px;
  font-weight: bold;
  margin: 0;
  padding: 0;
  color: inherit;
}

.result-footer {
  display: flex;
  justify-content: flex-end;
}

.result-btn {
  padding: 8px 20px;
  font-size: 13px;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.close-btn {
  background-color: #888;
}

.close-btn:hover {
  background-color: #666;
}

.remove-btn {
  background: none;
  border: none;
  color: #999;
  padding: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: color 0.2s, transform 0.15s;
}

.remove-btn:hover {
  color: var(--color-accent);
  transform: scale(1.2);
}

/* Confetti Animation */
.confetti-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
  z-index: 1001;
}

.confetti {
  position: absolute;
  top: -10px;
  width: 10px;
  height: 10px;
  opacity: 0;
  animation: confetti-fall linear forwards;
}

@keyframes confetti-fall {
  0% {
    opacity: 1;
    top: -10px;
    transform: translateX(0) rotateZ(0deg);
  }
  100% {
    opacity: 0;
    top: 100%;
    transform: translateX(calc(var(--drift, 50px) - 100px)) rotateZ(720deg);
  }
}

.confetti:nth-child(odd) {
  --drift: 150px;
}

.confetti:nth-child(even) {
  --drift: -50px;
}

.confetti:nth-child(3n) {
  width: 8px;
  height: 12px;
}

.confetti:nth-child(4n) {
  width: 12px;
  height: 8px;
}
  </style>
</head>
<body class="picker-wheel-demo">
  <div class="demo-container">
    <h1>Picker Wheel</h1>
    
    <div class="picker-wheel-wrapper">
      <!-- Wheel Section -->
      <div class="wheel-section">
        <div id="wheelCanvas" class="wheel-canvas"></div>
      </div>

      <!-- Options Input Section -->
      <div class="options-input-section">
        <input 
          type="text" 
          id="optionInput" 
          placeholder="Enter an option..." 
          class="option-input"
        >
        <div id="feedbackMessage" class="feedback-message"></div>
        <button id="addBtn" class="add-btn">Add</button>
      </div>

      <!-- Options List -->
      <div class="options-list">
        <div class="options-list-header">
          <h3>Current Options</h3>
          <button id="clearAllBtn" class="clear-all-btn">Clear All</button>
        </div>
        <ol id="optionsList" class="options-ol"></ol>
      </div>
    </div>

    <!-- Result Modal -->
    <div id="resultModal" class="result-modal">
      <div class="result-modal-content">
        <h2>ðŸŽ‰ Winner! ðŸŽ‰</h2>
        <div class="result-row">
          <p id="resultText" class="result-text"></p>
          <button id="removeOptionBtn" class="result-btn remove-btn" title="Remove"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg></button>
        </div>
        <div class="result-footer">
          <button id="closeModalBtn" class="result-btn close-btn">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script>
/*
  Picker Wheel JS
  Customization:
  - Override CSS variables via window.PickerWheelTheme, e.g. { '--color-primary': '#6c5ce7' }.
  - Override the slice palette via window.PickerWheelConfig = { palette: ['#..', ...] }.
  Place overrides before this script runs (above this block).
*/

/**
 * PickerWheel - A vanilla JavaScript picker wheel component
 * No dependencies required - pure vanilla JS
 */

class PickerWheel {
  constructor() {
    // Initialize state
    this.colorIndex = 0;
    this.options = [];
    // Pastel brand palette (cycles as options are added)
    this.palette = [
      '#3fb8af',
      '#c9f1ef',
      '#3fb8d4',
      '#ee7e8d',
      '#b83f69',
      '#f7c9b9',
      '#f5a623',
      '#f9d66b',
      '#2a7fb8'
    ];
    // Optional runtime theme overrides for CSS variables
    const theme = window.PickerWheelTheme;
    if (theme && typeof theme === 'object') {
      const root = document.documentElement;
      for (const [key, value] of Object.entries(theme)) {
        const varName = key.startsWith('--') ? key : `--${key}`;
        try { root.style.setProperty(varName, value); } catch (e) {}
      }
    }
    // Optional runtime palette override
    const cfg = window.PickerWheelConfig;
    if (cfg && Array.isArray(cfg.palette) && cfg.palette.length) {
      this.palette = cfg.palette.map(c => this.normalizeColor(c) || c);
    }
    // Initialize defaults using next available unique colors
    ['Yes','Yes','Yes','No','No','No'].forEach(text => {
      this.options.push({ text, color: this.getNextColor() });
    });

    // Basic safety limits to prevent abuse/overflow
    this.MAX_OPTIONS = 100;
    this.MAX_OPTION_LENGTH = 60;
    this.feedbackTimeout = null;
    this.initElements();
    this.attachEventListeners();
    // Load saved options and enforce unique colors before first render
    this.loadOptions();
    this.ensureUniqueColors();
    this.renderOptions();
  }

  getNextColor() {
    // Prefer an unused color from the fixed palette
    const currentOptions = Array.isArray(this.options) ? this.options : [];
    const used = new Set(
      currentOptions
        .map(o => this.normalizeColor(o.color))
        .filter(Boolean)
    );
    for (let i = 0; i < this.palette.length; i++) {
      const idx = (this.colorIndex + i) % this.palette.length;
      const candidate = this.palette[idx];
      if (!used.has(candidate)) {
        this.colorIndex = this.colorIndex + i + 1;
        return candidate;
      }
    }
    // If all palette colors are in use, generate a unique pastel via golden angle
    let attempts = 0;
    while (attempts < 360) {
      const hue = (this.colorIndex * 137.5) % 360;
      const candidate = this.hslToHex(hue, 60, 75);
      this.colorIndex++;
      attempts++;
      if (!used.has(candidate)) {
        return candidate;
      }
    }
    // Fallback (should never hit): return first palette color
    return this.palette[0];
  }

  initAudio() {
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }

  playClick() {
    if (!this.audioContext) {
      this.initAudio();
    }
    
    // Create a short burst of noise for a click sound
    const bufferSize = this.audioContext.sampleRate * 0.015; // 15ms
    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
    const data = buffer.getChannelData(0);
    
    // Fill with noise that decays quickly
    for (let i = 0; i < bufferSize; i++) {
      const decay = 1 - (i / bufferSize);
      data[i] = (Math.random() * 2 - 1) * decay * decay;
    }
    
    const source = this.audioContext.createBufferSource();
    source.buffer = buffer;
    
    const gainNode = this.audioContext.createGain();
    gainNode.gain.value = 0.3;
    
    // Add a filter to shape the click
    const filter = this.audioContext.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 1000;
    
    source.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    
    source.start();
  }

  playFanfare() {
    if (!this.audioContext) {
      this.initAudio();
    }
    
    // Victory fanfare - ascending arpeggio
    const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
    const startTime = this.audioContext.currentTime;
    
    notes.forEach((freq, i) => {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      oscillator.frequency.value = freq;
      oscillator.type = 'sine';
      
      const noteStart = startTime + (i * 0.12);
      const noteDuration = 0.3;
      
      gainNode.gain.setValueAtTime(0, noteStart);
      gainNode.gain.linearRampToValueAtTime(0.15, noteStart + 0.02);
      gainNode.gain.exponentialRampToValueAtTime(0.001, noteStart + noteDuration);
      
      oscillator.start(noteStart);
      oscillator.stop(noteStart + noteDuration);
    });
    
    // Final chord
    const chordTime = startTime + 0.5;
    [523.25, 659.25, 783.99, 1046.50].forEach(freq => {
      const osc = this.audioContext.createOscillator();
      const gain = this.audioContext.createGain();
      
      osc.connect(gain);
      gain.connect(this.audioContext.destination);
      
      osc.frequency.value = freq;
      osc.type = 'sine';
      
      gain.gain.setValueAtTime(0, chordTime);
      gain.gain.linearRampToValueAtTime(0.1, chordTime + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, chordTime + 0.8);
      
      osc.start(chordTime);
      osc.stop(chordTime + 0.8);
    });
  }

  createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    
    const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#1dd1a1'];
    
    for (let i = 0; i < 50; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = Math.random() * 100 + '%';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDelay = Math.random() * 0.5 + 's';
      confetti.style.animationDuration = (Math.random() * 1 + 2) + 's';
      
      // Random shape
      if (Math.random() > 0.5) {
        confetti.style.borderRadius = '50%';
      }
      
      confettiContainer.appendChild(confetti);
    }
    
    this.resultModal.appendChild(confettiContainer);
    
    // Remove confetti after animation
    setTimeout(() => {
      confettiContainer.remove();
    }, 3000);
  }

  initElements() {
    this.inputElement = document.getElementById('optionInput');
    this.addBtn = document.getElementById('addBtn');
    this.clearAllBtn = document.getElementById('clearAllBtn');
    this.feedbackMessage = document.getElementById('feedbackMessage');
    this.optionsList = document.getElementById('optionsList');
    this.wheelCanvas = document.getElementById('wheelCanvas');
    this.resultModal = document.getElementById('resultModal');
    this.resultText = document.getElementById('resultText');
    this.closeModalBtn = document.getElementById('closeModalBtn');
    this.removeOptionBtn = document.getElementById('removeOptionBtn');
    this.isSpinning = false;
    this.selectedIndex = null;
  }

  attachEventListeners() {
    this.clearAllBtn.addEventListener('click', () => this.handleClearAll());
    this.addBtn.addEventListener('click', () => this.handleAddOption());
    this.closeModalBtn.addEventListener('click', () => this.closeResultModal());
    this.removeOptionBtn.addEventListener('click', () => this.handleRemoveOption());
    this.inputElement.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        this.handleAddOption();
      }
    });
  }

  handleAddOption() {
    const value = this.inputElement.value.trim();

    // Validation: Empty input
    if (!value) {
      this.showFeedback('Please enter an option', 'error');
      return;
    }

    // Validation: Length cap
    if (value.length > this.MAX_OPTION_LENGTH) {
      this.showFeedback(`Option cannot exceed ${this.MAX_OPTION_LENGTH} characters`, 'error');
      return;
    }

    // Validation: Duplicate
    if (this.options.some(opt => opt.text === value)) {
      this.showFeedback('This option already exists', 'error');
      return;
    }

    // Validation: Max options
    if (this.options.length >= this.MAX_OPTIONS) {
      this.showFeedback('Maximum number of options reached', 'error');
      return;
    }

    // Add option with assigned color
    this.options.push({ text: value, color: this.getNextColor() });
    this.saveOptions();
    this.inputElement.value = '';
    this.inputElement.focus();
    this.renderOptions();
  }

  renderOptions() {
    this.optionsList.innerHTML = '';
    this.options.forEach((option, index) => {
      const li = document.createElement('li');
      li.className = 'option-item';
      
      const textSpan = document.createElement('span');
      textSpan.className = 'option-text';
      textSpan.textContent = option.text;
      textSpan.dataset.index = index;
      
      const buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'option-buttons';
      
      const editBtn = document.createElement('button');
      editBtn.className = 'edit-btn';
      editBtn.appendChild(this.createEditIconSvg());
      editBtn.title = 'Edit';
      editBtn.addEventListener('click', () => this.startEditOption(index, li, textSpan));
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-btn';
      deleteBtn.appendChild(this.createTrashIconSvg());
      deleteBtn.title = 'Delete';
      deleteBtn.addEventListener('click', () => this.handleDeleteOption(index));
      
      buttonsContainer.appendChild(editBtn);
      buttonsContainer.appendChild(deleteBtn);
      
      li.appendChild(textSpan);
      li.appendChild(buttonsContainer);
      this.optionsList.appendChild(li);
    });
    
    // Update wheel when options change
    this.renderWheel();
  }

  renderWheel() {
    this.wheelCanvas.innerHTML = '';
    
    if (this.options.length < 2) {
      const placeholder = document.createElement('div');
      placeholder.className = 'wheel-placeholder';
      placeholder.textContent = 'Add at least 2 options to spin the wheel';
      this.wheelCanvas.appendChild(placeholder);
      return;
    }
    // Create wrapper for rotation
    const wheelWrapper = document.createElement('div');
    wheelWrapper.className = 'wheel-wrapper';
    
    // Calculate offset to center first segment under arrow
    const segmentAngle = 360 / this.options.length;
    const initialOffset = segmentAngle / 2;
    
    // Set initial rotation if not already set, or preserve current rotation
    if (this.currentRotation === undefined) {
      this.currentRotation = -initialOffset;
    }
    wheelWrapper.style.transform = 'rotate(' + this.currentRotation + 'deg)';
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 200 200');
    svg.setAttribute('class', 'wheel-svg');
    
    this.options.forEach((option, index) => {
      const startAngle = index * segmentAngle;
      const endAngle = (index + 1) * segmentAngle;
      
      const slice = this.createSlice(100, 100, 80, startAngle, endAngle, option.color);
      svg.appendChild(slice);
      
      // Add text label
      const midAngle = (startAngle + endAngle) / 2;
      const text = this.createSliceText(option.text, 100, 100, midAngle);
      svg.appendChild(text);
    });
    
    // Add border circle to wheel
    const borderCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    borderCircle.setAttribute('cx', '100');
    borderCircle.setAttribute('cy', '100');
    borderCircle.setAttribute('r', '80');
    borderCircle.setAttribute('fill', 'none');
    borderCircle.setAttribute('stroke', '#999');
    borderCircle.setAttribute('stroke-width', '1');
    svg.appendChild(borderCircle);
    
    wheelWrapper.appendChild(svg);
    
    // Add spin button in center
    const spinBtn = document.createElement('button');
    spinBtn.className = 'spin-btn';
    spinBtn.textContent = 'SPIN';
    spinBtn.addEventListener('click', () => this.handleSpin());
    wheelWrapper.appendChild(spinBtn);
    
    this.wheelCanvas.appendChild(wheelWrapper);
    
    // Add arrow indicator outside wheel (doesn't rotate)
    const arrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    arrowSvg.setAttribute('viewBox', '0 0 60 60');
    arrowSvg.setAttribute('class', 'wheel-arrow-svg');
    
    // Original simple triangular arrow pointing left
    const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    // Inset the left tip slightly from the edge for visibility
    arrowPath.setAttribute('points', '5,30 35,10 35,50');
    arrowPath.setAttribute('fill', '#333');
    arrowPath.setAttribute('stroke', '#333');
    arrowPath.setAttribute('stroke-width', '2');
    arrowPath.setAttribute('stroke-linejoin', 'round');
    arrowPath.setAttribute('stroke-linecap', 'round');
    
    arrowSvg.appendChild(arrowPath);
    this.wheelCanvas.appendChild(arrowSvg);
  }

  handleSpin() {
    if (this.isSpinning) return;

    this.isSpinning = true;

    const wheelWrapper = this.wheelCanvas.querySelector('.wheel-wrapper');

    const duration = 10000; // 10s total spin
    const start = performance.now();

    // 8â€“12 full spins + random landing
    const spins = 8 + Math.random() * 4;
    const totalRotation = spins * 360;

    const startRotation = this.currentRotation || 0;
    
    // Initialize lastSegment to current segment so no click on first frame
    const initialNormalized = (startRotation % 360 + 360) % 360;
    const segmentAngle = 360 / this.options.length;
    let lastSegment = Math.floor(((0 - initialNormalized + 360) % 360) / segmentAngle) % this.options.length;

    // cubic ease-in-out (fast middle, slow ends)
    const easeInOutCubic = (t) =>
      t < 0.5
        ? 4 * t * t * t
        : 1 - Math.pow(-2 * t + 2, 3) / 2;

    const animate = (now) => {
      const elapsed = now - start;
      const progress = Math.min(elapsed / duration, 1);

      const eased = easeInOutCubic(progress);

      const rotation = startRotation + totalRotation * eased;

      wheelWrapper.style.transform = `rotate(${rotation}deg)`;
      
      // Check if a new segment is under the arrow and play click
      const normalizedRotation = (rotation % 360 + 360) % 360;
      const segmentAngle = 360 / this.options.length;
      const currentSegment = Math.floor(((0 - normalizedRotation + 360) % 360) / segmentAngle) % this.options.length;
      
      if (currentSegment !== lastSegment) {
        this.playClick();
        lastSegment = currentSegment;
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        this.currentRotation = rotation % 360;
        this.isSpinning = false;
        
        // Determine which option was selected
        const { option, index } = this.getSelectedOption(this.currentRotation);
        this.displayResult(option, index);
      }
    };

    requestAnimationFrame(animate);
  }

  getSelectedOption(rotation) {
    // Arrow points at 0 degrees (right side)
    // Normalize rotation to 0-360
    const normalizedRotation = (rotation % 360 + 360) % 360;
    
    // Find which segment is under the arrow on the right
    const segmentUnderArrow = (0 - normalizedRotation + 360) % 360;
    
    const segmentAngle = 360 / this.options.length;
    const selectedIndex = Math.floor(segmentUnderArrow / segmentAngle) % this.options.length;
    
    return {
      option: this.options[selectedIndex],
      index: selectedIndex
    };
  }

  displayResult(selectedOption, selectedIndex) {
    // Store the selected index for later use
    this.selectedIndex = selectedIndex;
    
    // Use the stored color from the option
    const color = selectedOption.color;
    
    // Update the text content
    this.resultText.innerText = selectedOption.text;
    
    // Apply color directly to the element
    this.resultText.style.color = color;
    
    // Show the modal
    this.resultModal.classList.add('show');
    
    // Play celebration effects
    this.playFanfare();
    this.createConfetti();
  }

  handleRemoveOption() {
    if (this.selectedIndex !== null) {
      this.options.splice(this.selectedIndex, 1);
      this.saveOptions();
      this.renderOptions();
    }
    this.closeResultModal();
  }

  closeResultModal() {
    this.resultModal.classList.remove('show');
    this.selectedIndex = null;
  }

  createSlice(cx, cy, radius, startAngle, endAngle, color) {
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const startRad = (startAngle * Math.PI) / 180;
    const endRad = (endAngle * Math.PI) / 180;
    
    const x1 = cx + radius * Math.cos(startRad);
    const y1 = cy + radius * Math.sin(startRad);
    const x2 = cx + radius * Math.cos(endRad);
    const y2 = cy + radius * Math.sin(endRad);
    
    const largeArc = endAngle - startAngle > 180 ? 1 : 0;
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const pathData = `M ${cx} ${cy} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
    path.setAttribute('d', pathData);
    path.setAttribute('fill', color);
    
    group.appendChild(path);
    return group;
  }

  // Safer SVG icon creation (no innerHTML)
  createEditIconSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttribute('viewBox', '0 0 24 24');
    svg.setAttribute('width', '16');
    svg.setAttribute('height', '16');
    svg.setAttribute('fill', 'none');
    svg.setAttribute('stroke', 'currentColor');
    svg.setAttribute('stroke-width', '2');
    svg.setAttribute('stroke-linecap', 'round');
    svg.setAttribute('stroke-linejoin', 'round');
    const p1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    p1.setAttribute('d', 'M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z');
    const p2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    p2.setAttribute('d', 'm15 5 4 4');
    svg.appendChild(p1);
    svg.appendChild(p2);
    return svg;
  }

  createTrashIconSvg() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttribute('viewBox', '0 0 24 24');
    svg.setAttribute('width', '16');
    svg.setAttribute('height', '16');
    svg.setAttribute('fill', 'none');
    svg.setAttribute('stroke', 'currentColor');
    svg.setAttribute('stroke-width', '2');
    svg.setAttribute('stroke-linecap', 'round');
    svg.setAttribute('stroke-linejoin', 'round');
    const p1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    p1.setAttribute('d', 'M3 6h18');
    const p2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    p2.setAttribute('d', 'M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6');
    const p3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    p3.setAttribute('d', 'M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2');
    const l1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    l1.setAttribute('x1', '10');
    l1.setAttribute('x2', '10');
    l1.setAttribute('y1', '11');
    l1.setAttribute('y2', '17');
    const l2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    l2.setAttribute('x1', '14');
    l2.setAttribute('x2', '14');
    l2.setAttribute('y1', '11');
    l2.setAttribute('y2', '17');
    svg.appendChild(p1);
    svg.appendChild(p2);
    svg.appendChild(p3);
    svg.appendChild(l1);
    svg.appendChild(l2);
    return svg;
  }

  createSliceText(text, cx, cy, angle) {
    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    const rad = (angle * Math.PI) / 180;
    const x = cx + 50 * Math.cos(rad);
    const y = cy + 50 * Math.sin(rad);
    
    textElement.setAttribute('x', x);
    textElement.setAttribute('y', y);
    textElement.setAttribute('text-anchor', 'middle');
    textElement.setAttribute('dominant-baseline', 'middle');
    textElement.setAttribute('fill', 'white');
    textElement.setAttribute('font-size', '12');
    textElement.setAttribute('font-weight', 'bold');
    textElement.setAttribute('pointer-events', 'none');
    
    // Rotate text to be readable
    const rotateDegrees = angle > 180 ? angle - 180 : angle;
    textElement.setAttribute('transform', `rotate(${rotateDegrees} ${x} ${y})`);
    textElement.textContent = text;
    
    return textElement;
  }

  startEditOption(index, li, textSpan) {
    const currentValue = this.options[index].text;
    
    // Create input field
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'option-input-edit';
    input.value = currentValue;
    
    // Create buttons container
    const editActionsContainer = document.createElement('div');
    editActionsContainer.className = 'edit-actions';
    
    const saveBtn = document.createElement('button');
    saveBtn.className = 'save-btn';
    saveBtn.textContent = 'Save';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'cancel-btn';
    cancelBtn.textContent = 'Cancel';
    
    editActionsContainer.appendChild(saveBtn);
    editActionsContainer.appendChild(cancelBtn);
    
    // Replace content with input
    li.innerHTML = '';
    li.appendChild(input);
    li.appendChild(editActionsContainer);
    input.focus();
    input.select();
    
    const saveEdit = () => {
      const trimmedValue = input.value.trim();
      
      // Validation: Empty input
      if (!trimmedValue) {
        this.showFeedback('Option cannot be empty', 'error');
        this.renderOptions();
        return;
      }
      
      // Validation: Duplicate (excluding current item)
      if (trimmedValue !== currentValue && this.options.some(opt => opt.text === trimmedValue)) {
        this.showFeedback('This option already exists', 'error');
        this.renderOptions();
        return;
      }

      // Validation: Length cap
      if (trimmedValue.length > this.MAX_OPTION_LENGTH) {
        this.showFeedback(`Option cannot exceed ${this.MAX_OPTION_LENGTH} characters`, 'error');
        this.renderOptions();
        return;
      }
      
      // Update option text (keep same color)
      this.options[index].text = trimmedValue;
      this.saveOptions();
      this.renderOptions();
    };
    
    saveBtn.addEventListener('click', saveEdit);
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        saveEdit();
      }
    });
    
    cancelBtn.addEventListener('click', () => this.renderOptions());
  }

  handleDeleteOption(index) {
    this.options.splice(index, 1);
    this.saveOptions();
    this.renderOptions();
  }

  handleClearAll() {
    this.options = [];
    this.saveOptions();
    this.renderOptions();
  }

  // Persist options in localStorage
  saveOptions() {
    try {
      // Persist with normalized hex colors
      const data = JSON.stringify(
        this.options.map(o => ({ text: o.text, color: this.normalizeColor(o.color) || o.color }))
      );
      localStorage.setItem('pickerWheelOptions', data);
    } catch (e) {
      // Ignore storage errors silently
    }
  }

  // Load options from localStorage if available
  loadOptions() {
    try {
      const raw = localStorage.getItem('pickerWheelOptions');
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        const cleaned = parsed
          .filter(o => o && typeof o.text === 'string')
          .map(o => ({
            text: o.text.trim(),
            color: this.normalizeColor(o.color) || this.getNextColor()
          }));
        if (cleaned.length) {
          this.options = cleaned;
        }
      }
    } catch (e) {
      // Ignore corrupted data
    }
  }

  // Ensure each option has a unique color; reassign duplicates
  ensureUniqueColors() {
    const used = new Set();
    for (let i = 0; i < this.options.length; i++) {
      let color = this.normalizeColor(this.options[i].color);
      if (!color || used.has(color)) {
        const available = this.palette.find(c => !used.has(c));
        if (available) {
          color = available;
        } else {
          let attempts = 0;
          while (attempts < 360) {
            const hue = (this.colorIndex * 137.5) % 360;
            const candidate = this.hslToHex(hue, 60, 75);
            this.colorIndex++;
            attempts++;
            if (!used.has(candidate)) {
              color = candidate;
              break;
            }
          }
          if (!color) {
            color = this.palette[0];
          }
        }
        this.options[i].color = color;
      }
      used.add(color);
    }
    this.saveOptions();
  }

  // Convert any CSS color string to normalized hex #rrggbb
  normalizeColor(color) {
    if (!color) return null;
    let c = color.toString().trim().toLowerCase();
    // Hex formats
    if (c.startsWith('#')) {
      if (c.length === 4) {
        // #abc -> #aabbcc
        const r = c[1], g = c[2], b = c[3];
        return `#${r}${r}${g}${g}${b}${b}`;
      }
      if (c.length === 7) return c;
      return c; // leave as-is
    }
    // rgb/rgba
    const rgb = c.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
    if (rgb) {
      const r = parseInt(rgb[1], 10), g = parseInt(rgb[2], 10), b = parseInt(rgb[3], 10);
      const toHex = (n) => n.toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    // hsl/hsla
    const hsl = c.match(/hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%/);
    if (hsl) {
      const h = parseFloat(hsl[1]);
      const s = parseFloat(hsl[2]);
      const l = parseFloat(hsl[3]);
      return this.hslToHex(h, s, l);
    }
    // Named colors and unknown formats: use computed style to resolve
    try {
      const temp = document.createElement('span');
      temp.style.color = c;
      document.body.appendChild(temp);
      const resolved = getComputedStyle(temp).color; // rgb(...)
      temp.remove();
      const rgb2 = resolved.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
      if (rgb2) {
        const r = parseInt(rgb2[1], 10), g = parseInt(rgb2[2], 10), b = parseInt(rgb2[3], 10);
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }
    } catch (e) {}
    return c;
  }

  // Convert HSL to hex #rrggbb
  hslToHex(h, s, l) {
    // Normalize ranges
    h = ((h % 360) + 360) % 360;
    s = Math.max(0, Math.min(100, s)) / 100;
    l = Math.max(0, Math.min(100, l)) / 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    const m = l - c / 2;
    let r1 = 0, g1 = 0, b1 = 0;
    if (h < 60) { r1 = c; g1 = x; b1 = 0; }
    else if (h < 120) { r1 = x; g1 = c; b1 = 0; }
    else if (h < 180) { r1 = 0; g1 = c; b1 = x; }
    else if (h < 240) { r1 = 0; g1 = x; b1 = c; }
    else if (h < 300) { r1 = x; g1 = 0; b1 = c; }
    else { r1 = c; g1 = 0; b1 = x; }
    const toHex = (n) => Math.round((n + m) * 255).toString(16).padStart(2, '0');
    return `#${toHex(r1)}${toHex(g1)}${toHex(b1)}`;
  }

  showFeedback(message, type) {
    // Clear any existing timeout
    if (this.feedbackTimeout) {
      clearTimeout(this.feedbackTimeout);
    }
    
    this.feedbackMessage.textContent = message;
    this.feedbackMessage.className = `feedback-message ${type}`;
    
    // Trigger fade-in
    setTimeout(() => {
      this.feedbackMessage.classList.add('show');
    }, 10);
    
    // Auto-hide feedback after 3 seconds
    this.feedbackTimeout = setTimeout(() => {
      this.feedbackMessage.classList.remove('show');
    }, 3000);
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  new PickerWheel();
});
  </script>
</body>
</html>
